# Spec-Driven Development with GitHub Copilot

This template integrates **spec-driven development** as described in the [GitHub Blog post](https://github.blog/ai-and-ml/generative-ai/spec-driven-development-using-markdown-as-a-programming-language-when-building-with-ai/) by Tomas Vesely (@wham).

## üìù Overview

**Spec-driven development** treats Markdown as a programming language where:
- **Specifications** are the source code
- **GitHub Copilot** is the compiler
- **Tests** verify the "compiled" implementation
- **Linting** optimizes specifications for clarity

Instead of writing code directly, you write clear specifications in Markdown, then use Copilot to generate the implementation.

## üîÑ Workflow

```
1. Write Specification     2. Lint (Optional)      3. Compile to Code       4. Test & Deploy
   (Markdown)                 (Optimize)              (Copilot)                (CI/CD)
   
   requirements-spec.md  ‚Üí  lint.prompt.md  ‚Üí  compile.prompt.md  ‚Üí  Tests pass? ‚úÖ
         ‚Üì                        ‚Üì                    ‚Üì                     ‚Üì
   Define what to build   Remove duplication   Generate code          Production
```

## üìÅ Files in This Template

### Core Prompts (Spec-Driven Development)

#### `.github/prompts/lint.prompt.md`

**Purpose**: Optimize specifications for clarity and AI comprehension

**What it does**:
- Standardizes terminology (eliminates synonyms)
- Removes duplicate content
- Simplifies verbose language
- Maintains consistent structure
- Preserves all technical details

**When to use**:
- After writing initial specification
- Before specification review
- When spec becomes large (>500 lines)
- Before major releases

**How to use**:
```bash
# In VS Code with GitHub Copilot
1. Open your specification file (e.g., requirements-spec.md)
2. Open Copilot Chat
3. Type: / then select lint.prompt.md
4. Review and accept optimizations
```

**Example transformation**:

‚ùå **Before** (verbose, inconsistent):
```markdown
The system should provide the capability for users to be able to 
perform authentication using their email address and password credentials.
The system should be able to retrieve the user record from the database.
The system should be able to validate the password.
```

‚úÖ **After** (concise, consistent):
```markdown
The system shall authenticate users via email and password:
1. Retrieve user by email
2. Validate password against bcrypt hash
3. Create session token on success
```

### `.github/prompts/compile.prompt.md`

**Purpose**: Transform specifications into working code

**What it does**:
- Reads specification thoroughly
- Generates tests FIRST (TDD)
- Implements code to pass tests
- Maintains full traceability
- Follows standards and XP practices

**When to use**:
- After specification is complete and reviewed
- When adding new features
- When fixing bugs (update spec, then recompile)

**How to use**:
```bash
# In VS Code with GitHub Copilot
1. Open your specification file
2. Open Copilot Chat
3. Type: / then select compile.prompt.md
4. Optional: Add "focus on <specific-section>"
5. Copilot generates:
   - Test files (RED)
   - Implementation (GREEN)
   - Documentation
```

**Example**:

**Input** (specification):
```markdown
## User Authentication

**REQ-F-001**: Authenticate users via email and password
- Use bcrypt for password hashing
- Create JWT token on success (24h expiry)
- Return 401 for invalid credentials

### Acceptance Criteria

Given valid credentials
When user authenticates
Then JWT token is returned
And token expires in 24 hours
```

**Output** (generated by Copilot):

1. **Tests** (generated FIRST):
```typescript
// tests/auth.test.ts
describe('User Authentication - REQ-F-001', () => {
  it('should authenticate with valid credentials', async () => {
    const result = await authenticateUser('user@example.com', 'password');
    expect(result.token).toBeDefined();
    expect(result.expiresIn).toBe(86400); // 24 hours
  });
  
  it('should return 401 for invalid credentials', async () => {
    await expect(
      authenticateUser('user@example.com', 'wrong')
    ).rejects.toThrow('Unauthorized');
  });
});
```

2. **Implementation** (generated AFTER tests):
```typescript
// src/auth.ts
/**
 * @implements REQ-F-001 - User authentication
 */
export async function authenticateUser(email: string, password: string) {
  const user = await db.users.findByEmail(email);
  if (!user) throw new Error('Unauthorized');
  
  const valid = await bcrypt.compare(password, user.passwordHash);
  if (!valid) throw new Error('Unauthorized');
  
  const token = jwt.sign({ userId: user.id }, SECRET, { expiresIn: '24h' });
  return { token, expiresIn: 86400 };
}
```

## üéØ Benefits

### 1. **Specifications Stay Current**

Traditional development:
```
Spec written ‚Üí Code evolves ‚Üí Spec becomes outdated ‚ùå
```

Spec-driven development:
```
Spec IS the source ‚Üí Update spec ‚Üí Recompile ‚Üí Code updated ‚úÖ
```

### 2. **No Context Loss**

Copilot always has full context because specifications contain:
- Requirements with traceability IDs
- Design decisions (ADRs)
- Acceptance criteria
- Technical constraints

### 3. **Faster Iteration**

```
Write detailed spec once ‚Üí Compile to code ‚Üí Iterate on spec ‚Üí Recompile
```

Faster than repeatedly explaining context in chat prompts.

### 4. **Better Quality**

- All code generated from specs
- Tests generated first (TDD)
- Full traceability maintained
- Standards automatically applied

### 5. **Language Agnostic**

Same specification can be compiled to:
- TypeScript
- Python
- Go
- Java
- Any language Copilot supports

## üìö Integration with This Template

### Phase-Specific Specs

Each phase has its own specification approach:

| Phase | Specification Type | Template |
|-------|-------------------|----------|
| 01-Stakeholder | Stakeholder Requirements | stakeholder-requirements.md |
| 02-Requirements | System Requirements | requirements-spec.md |
| 03-Architecture | Architecture Description | architecture-spec.md |
| 04-Design | Design Specifications | design-spec.md |
| 05-Implementation | Implementation Specs | user-story-template.md |
| 06-Integration | Integration Test Specs | integration-spec.md |
| 07-V&V | Test Specifications | test-spec.md |
| 08-Transition | Deployment Plans | deployment-spec.md |
| 09-Operations | Operations Manual | operations-spec.md |

### Using with Copilot Instructions

The template combines:

1. **Phase-specific copilot-instructions.md**: Context for current phase
2. **Spec-Kit templates**: Starting point for specifications
3. **Lint prompt**: Optimize specifications
4. **Compile prompt**: Generate code from specs

All working together:

```
Phase folder ‚îÄ‚î¨‚îÄ‚ñ∫ copilot-instructions.md (automatic context)
              ‚îÇ
Your spec ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚ñ∫ lint.prompt.md (optimize spec)
              ‚îÇ
              ‚îî‚îÄ‚ñ∫ compile.prompt.md (generate code)
                         ‚Üì
                  Implementation with:
                  - Tests (TDD)
                  - Traceability
                  - Standards compliance
```

## üõ†Ô∏è Example: Complete Workflow

### Step 1: Create Specification

```bash
cd 02-requirements
cp ../spec-kit-templates/requirements-spec.md payment-processing-spec.md
code payment-processing-spec.md
```

Write your specification:

```markdown
# Payment Processing Specification

## REQ-F-010: Process Payment

The system shall process credit card payments using Stripe API.

### Implementation Requirements
- Use Stripe SDK v12.x
- Store payment intent ID in database
- Handle 3D Secure authentication
- Retry failed payments (max 3 attempts)
- Log all payment attempts

### Acceptance Criteria

**Scenario: Successful Payment**
Given a valid credit card
When payment is processed
Then payment intent is created
And payment succeeds
And order is marked as paid

**Scenario: Payment Failure**
Given an invalid card
When payment is processed
Then payment fails
And error is logged
And retry is attempted (max 3 times)
And user is notified
```

### Step 2: Lint Specification (Optional)

```
In Copilot Chat:
/lint.prompt.md

Copilot optimizes:
- Removes redundancy
- Standardizes "process/handle/execute" to just "process"
- Simplifies verbose phrases
```

### Step 3: Compile to Code

```
In Copilot Chat:
/compile.prompt.md focus on payment processing

Copilot generates:
1. tests/payment.test.ts (TDD - tests first!)
2. src/payment.ts (implementation)
3. Includes traceability comments
```

Generated test:

```typescript
describe('Payment Processing - REQ-F-010', () => {
  it('should process successful payment', async () => {
    const result = await processPayment({
      amount: 1000,
      currency: 'USD',
      cardToken: 'tok_visa'
    });
    
    expect(result.success).toBe(true);
    expect(result.paymentIntentId).toBeDefined();
  });
  
  it('should retry failed payment up to 3 times', async () => {
    // Test implementation
  });
});
```

Generated implementation:

```typescript
/**
 * Process credit card payment using Stripe.
 * 
 * @implements REQ-F-010 - Process Payment
 * @traces StR-008 - Stakeholder requirement for payment processing
 */
export async function processPayment(params: PaymentParams): Promise<PaymentResult> {
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);
  
  let attempts = 0;
  const maxAttempts = 3;
  
  while (attempts < maxAttempts) {
    try {
      const paymentIntent = await stripe.paymentIntents.create({
        amount: params.amount,
        currency: params.currency,
        payment_method: params.cardToken,
        confirm: true
      });
      
      await db.payments.create({
        paymentIntentId: paymentIntent.id,
        amount: params.amount,
        status: 'succeeded'
      });
      
      logger.info('Payment succeeded', { paymentIntentId: paymentIntent.id });
      
      return { success: true, paymentIntentId: paymentIntent.id };
    } catch (error) {
      attempts++;
      logger.error('Payment attempt failed', { attempt: attempts, error });
      
      if (attempts >= maxAttempts) {
        throw new PaymentError('Payment failed after 3 attempts');
      }
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
    }
  }
}
```

### Step 4: Test and Deploy

```bash
# Tests run automatically
npm test

# CI/CD pipeline runs
git push

# If all checks pass ‚Üí Deploys to staging
```

## üîç Comparison with Traditional Development

### Traditional Approach

```
1. Write vague requirements
2. Developer interprets requirements
3. Code written (may diverge from intent)
4. Tests written after (if at all)
5. Documentation becomes outdated
6. Future developers lost without context
```

### Spec-Driven Approach

```
1. Write detailed specification (Markdown)
2. Lint for clarity
3. Compile to code (Copilot)
4. Tests generated first (TDD)
5. Documentation IS the specification
6. Future: just read the spec and recompile
```

## ÔøΩÔ∏è Standards Enforcement with Validation Prompts

This template includes **5 validation prompts** that enforce IEEE/ISO/IEC standards compliance throughout your development process.

### 1. **requirements-validate.prompt.md** üìã

**Enforces**: ISO/IEC/IEEE 29148:2018 - Requirements Engineering

**What it validates**:
- ‚úÖ Completeness: All stakeholder needs have requirements
- ‚úÖ Consistency: No conflicts, consistent terminology
- ‚úÖ Correctness: Technically feasible, no ambiguity
- ‚úÖ Testability: Every requirement has Given-When-Then acceptance criteria
- ‚úÖ Traceability: All requirements trace to stakeholder needs
- ‚úÖ Measurability: Non-functional requirements have quantifiable metrics

**When to use**: After writing/updating requirements specification

**How to use**:
```bash
# In VS Code Copilot Chat
/requirements-validate.prompt.md
```

**Output**: Detailed validation report with:
- Requirements coverage score (target: 95%+)
- Critical issues (missing acceptance criteria, ambiguous language)
- Traceability matrix
- Compliance score per ISO 29148 criteria

### 2. **tdd-compile.prompt.md** üß™

**Enforces**: Test-Driven Development (TDD) + ISO/IEC/IEEE 12207:2017

**What it does**:
- üî¥ **RED**: Generates comprehensive test suite FIRST (failing tests)
- üü¢ **GREEN**: Generates minimal implementation to pass tests
- üîÑ **REFACTOR**: Suggests improvements while keeping tests green
- üìù Maintains full traceability (requirement ‚Üí test ‚Üí code)

**When to use**: When implementing features from specifications

**How to use**:
```bash
# In VS Code Copilot Chat
/tdd-compile.prompt.md focus on REQ-F-001
```

**Output**: 
1. Complete test suite with:
   - Happy path tests
   - Error handling tests
   - Edge case tests
   - Boundary value tests
2. Implementation with traceability annotations
3. Refactoring suggestions

**Key Rules Enforced**:
- Tests ALWAYS written before code
- Minimal code to pass tests (no speculative features)
- 100% traceability (every function documents `@implements REQ-XXX`)

### 3. **test-validate.prompt.md** ‚úÖ

**Enforces**: IEEE 1012-2016 - Verification and Validation

**What it validates**:
- ‚úÖ Requirements coverage: Every requirement has ‚â•1 test
- ‚úÖ Code coverage: Line ‚â•80%, Branch ‚â•75%, Function =100%
- ‚úÖ Test quality: AAA pattern, descriptive names, proper assertions
- ‚úÖ Test types: Unit, Integration, System, Performance, Security
- ‚úÖ Traceability: Tests trace to requirements

**When to use**: Before commits, before releases, in CI/CD

**How to use**:
```bash
# In VS Code Copilot Chat
/test-validate.prompt.md
```

**Output**: Comprehensive V&V report with:
- Test coverage metrics per module
- Requirements traceability matrix (REQ ‚Üî TEST)
- Untested code locations (file:line)
- Test quality score
- Missing test types (e.g., no security tests)
- IEEE 1012 compliance score

### 4. **traceability-validate.prompt.md** üîó

**Enforces**: ISO/IEC/IEEE 12207:2017 - Lifecycle Traceability

**What it validates**:
- ‚úÖ Forward traceability: StR ‚Üí REQ ‚Üí DES ‚Üí CODE ‚Üí TEST
- ‚úÖ Backward traceability: TEST ‚Üí CODE ‚Üí DES ‚Üí REQ ‚Üí StR
- ‚úÖ Traceability matrix completeness
- ‚úÖ No orphan artifacts (code without requirements)
- ‚úÖ No missing implementations (requirements without code)

**When to use**: Weekly, before releases, during audits

**How to use**:
```bash
# In VS Code Copilot Chat
/traceability-validate.prompt.md
```

**Output**: End-to-end traceability report with:
- Complete traceability matrix (StR ‚Üí REQ ‚Üí DES ‚Üí CODE ‚Üí TEST)
- Broken traceability chains (e.g., requirement without design)
- Orphan artifacts (code without requirements = tech debt!)
- Missing implementations (requirements not coded)
- Forward and backward traceability scores
- Overall traceability compliance (target: 95%+)

### 5. **standards-validate.prompt.md** üìú

**Enforces**: ALL 5 IEEE/ISO/IEC Standards Cross-Validation

**Standards checked**:
1. ISO/IEC/IEEE 12207:2017 - Software lifecycle processes
2. ISO/IEC/IEEE 29148:2018 - Requirements engineering
3. IEEE 1016-2009 - Software design descriptions
4. ISO/IEC/IEEE 42010:2011 - Architecture description
5. IEEE 1012-2016 - Verification and validation

**What it validates**:
- ‚úÖ All lifecycle phases complete (01-09)
- ‚úÖ Requirements compliance (ISO 29148)
- ‚úÖ Architecture compliance (IEEE 42010)
- ‚úÖ Design compliance (IEEE 1016)
- ‚úÖ V&V compliance (IEEE 1012)
- ‚úÖ Process compliance (ISO 12207)

**When to use**: Before major releases, for certification, quarterly audits

**How to use**:
```bash
# In VS Code Copilot Chat
/standards-validate.prompt.md
```

**Output**: Comprehensive compliance report with:
- Compliance score per standard (target: 95%+ each)
- Overall compliance score (target: 95%+)
- Critical issues per standard
- Cross-standard compliance matrix
- Certification readiness assessment
- Remediation plan (immediate, short-term, long-term actions)

### Validation Workflow

```
1. Write Specification
   ‚Üì
2. Lint Specification (lint.prompt.md)
   ‚Üì
3. Validate Requirements (requirements-validate.prompt.md) ‚úÖ
   ‚Üì
4. Generate Tests + Code (tdd-compile.prompt.md) üß™
   ‚Üì
5. Validate Tests (test-validate.prompt.md) ‚úÖ
   ‚Üì
6. Validate Traceability (traceability-validate.prompt.md) üîó
   ‚Üì
7. Cross-Validate Standards (standards-validate.prompt.md) üìú
   ‚Üì
8. Fix Issues & Re-Validate
   ‚Üì
9. Deploy (when all validations ‚â•95%) ‚úÖ
```

### Integration with CI/CD

Add validation to your pipeline:

```yaml
# .github/workflows/standards-compliance.yml
name: Standards Compliance

on: [push, pull_request]

jobs:
  validate-requirements:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Validate Requirements
        run: gh copilot validate requirements --threshold 95
  
  validate-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run Tests with Coverage
        run: npm test -- --coverage
      - name: Validate Test Quality
        run: gh copilot validate tests --threshold 95
  
  validate-traceability:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Validate Traceability
        run: gh copilot validate traceability --threshold 95
  
  validate-standards:
    runs-on: ubuntu-latest
    needs: [validate-requirements, validate-tests, validate-traceability]
    steps:
      - uses: actions/checkout@v3
      - name: Cross-Validate All Standards
        run: gh copilot validate standards --threshold 95
```

### Compliance Scores Explained

| Score | Status | Meaning |
|-------|--------|---------|
| 95-100% | ‚úÖ Compliant | Production-ready, certification-ready |
| 85-94% | ‚ö†Ô∏è Mostly Compliant | Minor gaps, fix before release |
| 75-84% | üü° Needs Work | Significant gaps, not release-ready |
| <75% | üî¥ Non-Compliant | Major gaps, extensive work needed |

### Best Practices

1. **Validate Early and Often**
   - Run `requirements-validate` after every requirement change
   - Run `test-validate` before every commit
   - Run `traceability-validate` weekly
   - Run `standards-validate` before every release

2. **Fix Critical Issues First**
   - üî¥ Critical: Security risks, broken traceability, untested code
   - üü° High: Missing acceptance criteria, incomplete documentation
   - ‚ö†Ô∏è Medium: Orphan artifacts, test quality issues
   - üí° Low: Formatting, style, minor optimizations

3. **Maintain High Scores**
   - Target: ‚â•95% compliance for production releases
   - Minimum: ‚â•85% compliance for internal releases
   - Block releases if <85% compliance

4. **Use in Code Reviews**
   - Reviewer runs validation prompts on PR
   - PR must pass all validations before merge
   - Include compliance scores in PR description

## ÔøΩüìñ Further Reading

- **GitHub Blog**: [Spec-driven development](https://github.blog/ai-and-ml/generative-ai/spec-driven-development-using-markdown-as-a-programming-language-when-building-with-ai/)
- **Example Project**: [GitHub Brain MCP Server](https://github.com/wham/github-brain) by @wham
- **GitHub Spec-Kit**: [Spec-driven development toolkit](https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/)
- **Copilot Prompt Files**: [VS Code documentation](https://docs.github.com/en/copilot/tutorials/customization-library/prompt-files/your-first-prompt-file)
- **IEEE/ISO Standards**: Available through IEEE Xplore and ISO catalogs

## üéì Tips for Success

### Writing Good Specifications

‚úÖ **Do**:
- Be specific and precise
- Include concrete examples
- Define exact API signatures
- Specify error handling
- Add acceptance criteria
- Use consistent terminology

‚ùå **Don't**:
- Be vague or ambiguous
- Use multiple terms for same concept
- Skip error cases
- Forget edge cases
- Leave out technical details

### Using the Prompts

- **Lint frequently**: Keep specs clean as they grow
- **Compile incrementally**: Start with core, add features iteratively
- **Review generated code**: Copilot is smart but not perfect
- **Test thoroughly**: Generated code should pass all tests
- **Maintain traceability**: Every requirement should be implemented

### Best Practices

1. **Specs first, always**: Never code without spec
2. **Version control specs**: Specs are source code now
3. **Code reviews include specs**: Review both spec and generated code
4. **CI validates specs**: Check for consistency and completeness
5. **Update specs, not code**: Change spec ‚Üí recompile

---

**The key insight**: When you treat Markdown specifications as source code and Copilot as a compiler, you get:
- Better documentation (always up-to-date)
- Faster development (Copilot handles boilerplate)
- Higher quality (TDD, standards compliance)
- Easier maintenance (just update the spec)

Welcome to **spec-driven development**! üöÄ
